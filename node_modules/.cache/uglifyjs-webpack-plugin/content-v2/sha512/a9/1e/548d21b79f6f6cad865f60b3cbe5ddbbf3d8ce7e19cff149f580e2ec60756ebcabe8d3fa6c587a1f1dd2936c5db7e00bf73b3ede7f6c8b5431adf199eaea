{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\",\"/home/igor/Desktop/insurance/scripts.js\",\"/home/igor/Desktop/insurance/script.js\",\"/home/igor/Desktop/insurance/script2.js\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"Policy\",\"[object Object]\",\"nameOfInsuredObject\",\"validFrom\",\"validMonths\",\"selectedRisks\",\"this\",\"_nameOfInsuredObject\",\"_validFrom\",\"_validMonths\",\"_selectedRisks\",\"from\",\"months\",\"fromCopy\",\"Date\",\"getTime\",\"till\",\"setMonth\",\"getMonth\",\"setDate\",\"getDate\",\"validTill\",\"date\",\"month\",\"day\",\"year\",\"getFullYear\",\"length\",\"join\",\"formatDate\",\"calculateValidTill\",\"validTillUnformatted\",\"premium\",\"sum\",\"insuredRisks\",\"forEach\",\"elem\",\"_yearlyPrice\",\"Math\",\"ceil\",\"arr\",\"push\",\"dateNotPast\",\"nowDate\",\"InsuranceCompany\",\"_name\",\"_risks\",\"_soldPolicies\",\"availableRisks\",\"policy\",\"soldPolicies\",\"risks\",\"Array\",\"risk\",\"keys\",\"currentRisk\",\"includes\",\"console\",\"log\",\"isAvailable\",\"overlap\",\"policyClass\",\"f2\",\"t2\",\"el\",\"f1\",\"t1\",\"newPolicy\",\"addSoldPolicy\",\"effectiveDate\",\"toReturn\",\"policies\",\"efDateTime\",\"getPolicy\",\"Risk\",\"yearlyPrice\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n \\t\\t}\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// create a fake namespace object\\n \\t// mode & 1: value is a module id, require it\\n \\t// mode & 2: merge all properties of value into the ns\\n \\t// mode & 4: return value when already ns object\\n \\t// mode & 8|1: behave like require\\n \\t__webpack_require__.t = function(value, mode) {\\n \\t\\tif(mode & 1) value = __webpack_require__(value);\\n \\t\\tif(mode & 8) return value;\\n \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n \\t\\tvar ns = Object.create(null);\\n \\t\\t__webpack_require__.r(ns);\\n \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n \\t\\treturn ns;\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 0);\\n\",\"require('./script.js');\\nrequire('./script2.js');\",\"class InsuranceCompany {\\n\\n\\tconstructor(name) {\\n\\t\\tthis._name = name;\\n\\t\\tthis._risks = [];\\n\\t\\tthis._soldPolicies = [];\\n\\t}\\n\\n\\t// Get name of the company\\n\\tget name() {\\n\\t\\treturn this._name;\\n\\t}\\n\\t\\n\\t// Get list of the risks that can be insured.\\n\\tget availableRisks() {\\n\\t\\treturn this._risks;\\n\\t}\\n\\t\\n\\t// Add a new policy to the list\\n\\taddSoldPolicy(policy) {\\n\\t\\tthis._soldPolicies.push(policy);\\n\\t}\\n\\n\\t// Get list of all sold policies\\n\\tget soldPolicies() {\\n\\t\\treturn this._soldPolicies;\\n\\t}\\n\\t\\n\\t// Set list of the risks that can be insured. List can be updated at any time.\\n\\t// risks: Array of Risks or single Risk\\n\\tsetAvailableRisks(risks) {\\n\\t\\tthis._risks = [];\\n\\t\\tif(!(risks instanceof Array)) this._risks.push(risks); //if only one element is passed, will not use foreach\\n\\t\\telse {\\n\\t\\t\\trisks.forEach(function(elem){\\n\\t\\t\\t\\tthis._risks.push(elem);\\n\\t\\t\\t}, this);\\n\\t\\t}\\n\\t}\\n\\n\\t// Return true if Risk is available\\n\\t// risks: Array of Risks \\n\\tisAvailable(risks) {\\n\\t\\tfor (let risk of Object.keys(risks)) {\\n\\t\\t    let currentRisk = risks[risk];\\n\\t\\t\\tif (!this.availableRisks.includes(currentRisk)) { // If one of selected risks is not available reject to sell policy\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\t// Sell the policy.\\n\\t// nameOfInsuredObject: Name of the insured object. Must be unique in the given period.\\n\\t// validFrom: Date and time when policy starts. Can not be in the past\\n\\t// validMonths: (number) Policy period in full months\\n\\t// selectedRisks: List of risks objects that must be included in the policy\\n\\tsellPolicy(nameOfInsuredObject, validFrom, validMonths, selectedRisks) {\\n\\t\\tif(!dateNotPast(validFrom)) {\\n\\t\\t\\tconsole.log('error: Policy date can not be in the past');\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tif(!this.isAvailable(selectedRisks)) return; //refuse to sell policy if risk is not available\\n\\n\\t\\tlet overlap = false;\\n\\t\\tlet policyClass = new Policy(); //create an instance of class to access calculateValidTill method\\n\\t\\tlet f2 = validFrom.getTime(); // validFrom candidate for new Policy object\\n\\t\\tlet t2 = policyClass.calculateValidTill(validFrom,validMonths).getTime(); // validTill candidate for new Policy object\\n\\n\\t\\tlet sp = this.soldPolicies;\\n\\n\\t\\tsp.forEach(function(el){\\n\\t\\t\\tlet f1 = el._validFrom.getTime(); // validFrom already existing Policy object\\n\\t\\t\\tlet t1 = el.validTillUnformatted.getTime(); // valid Till already existing Policy object\\n\\t\\t\\t\\n\\t\\t\\t/*\\n\\t\\t\\tcases when effective periods overlap each other:\\n\\t\\t\\t\\tf2<=f1 && t2>=t1\\n\\t\\t\\t\\tf2>=f1 && f2<=t1\\n\\t\\t\\t\\tt2>=f1 && f2<=f1\\n\\n\\t\\t\\t\\tf - from , t - to\\n\\t\\t\\t\\t1 - already existing Policy object\\n\\t\\t\\t\\t2 - candidate for new Policy object\\n\\t\\t\\t*/\\n\\t\\t\\tif (((f2<=f1 && t2>=t1) || (f2>=f1 && f2<=t1) || (t2>=f1 && f2<=f1)) && nameOfInsuredObject == el.nameOfInsuredObject) \\n\\t\\t\\t\\toverlap = true;\\n\\t\\t});\\n\\n\\t\\tif(!overlap) {\\n\\t\\t\\tlet newPolicy = new Policy(nameOfInsuredObject, validFrom, validMonths, selectedRisks);\\n\\t\\t\\tthis.addSoldPolicy(newPolicy);\\n\\t\\t\\treturn newPolicy;\\n\\t\\t} else {\\n\\t\\t\\tconsole.log('error: Effective periods of different policies overlap each other');\\n\\t\\t}\\n\\t}\\n\\n\\t// Gets policy with a risks at the given point of time.\\n\\t// nameOfInsuredObject: Name of insured object\\n\\t// effectiveDate: Point of date and time, when to get data about a policy\\n\\tgetPolicy(nameOfInsuredObject, effectiveDate) {\\n\\t\\tlet policies = this._soldPolicies;\\n\\t\\tlet efDateTime = effectiveDate.getTime();\\n\\t\\tlet toReturn;\\n\\n\\t\\tpolicies.forEach(function(el){\\n\\t\\t\\tif (el.nameOfInsuredObject == nameOfInsuredObject && (efDateTime >= el.validFrom.getTime() && efDateTime <= el.validTillUnformatted.getTime())) {\\n\\t\\t\\t\\ttoReturn = el;\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\treturn toReturn;\\n\\t}\\n\\n\\t// Add risk to the policy of insured object.\\n\\t// nameOfInsuredObject: Name of insured object\\n\\t// risk: Risk that must be added\\n\\t// validFrom: Date when _policy_ becomes active. Can not be in the past\\n\\taddRisk(nameOfInsuredObject, risk, validFrom) {\\n\\t\\tif(!this.isAvailable([risk])) return; //refuse to add risk if not available\\n\\n\\t\\tif(dateNotPast(validFrom)) {\\n\\t\\t\\tlet currentPolicy = this.getPolicy(nameOfInsuredObject, validFrom);\\n\\t\\t\\tcurrentPolicy._selectedRisks.push(risk);\\n\\t\\t} else {\\n\\t\\t\\tconsole.log('error: Risk date can not be in the past');\\n\\t\\t}\\n\\t}\\n}\\n\\nclass Risk {\\n\\n\\tconstructor(name, yearlyPrice) {\\n\\t\\tthis._name = name;\\n\\t\\tthis._yearlyPrice = yearlyPrice;\\n\\t}\\n\\n\\t// Get name of the Risk\\n\\tget name() {\\n\\t\\treturn this._name;\\n\\t}\\n\\n\\t// Get yearly price of the Risk\\n\\tyearlyPrice() {\\n\\t\\treturn this._yearlyPrice;\\n\\t}\\n}\\n\\t\\nclass Policy {\\n\\n\\tconstructor(nameOfInsuredObject, validFrom, validMonths, selectedRisks) {\\n\\t\\tthis._nameOfInsuredObject = nameOfInsuredObject;\\n\\t\\tthis._validFrom = validFrom;\\n\\t\\tthis._validMonths = validMonths;\\n\\t\\tthis._selectedRisks = selectedRisks;\\n\\t}\\n\\n\\t// Get name of insured object.\\n\\tget nameOfInsuredObject() {\\n\\t\\treturn this._nameOfInsuredObject;\\n\\t}\\n\\t\\n\\t// Get date when policy becomes active.\\n\\tget validFrom() {\\n\\t\\treturn this._validFrom;\\n\\t}\\n\\n\\t// Get date when policy becomes inactive\\n\\t// from: Date and time when policy starts. Can not be in the past\\n\\t// months: (number) Policy period in full months\\n\\tcalculateValidTill(from, months) {\\n\\t\\tlet fromCopy = new Date(from.getTime()); //copy the argument to not change the original\\n\\t\\tlet till = new Date(fromCopy.setMonth(fromCopy.getMonth()+months));\\n\\t\\treturn new Date(till.setDate(till.getDate()-1)); //convert to needed form\\n\\t}\\n\\n\\t// Get date when policy becomes inactive.\\n\\tget validTill() {\\n\\t\\treturn formatDate(this.calculateValidTill(this._validFrom, this._validMonths)); //return String in the 'yyyy-mm-dd' format\\n\\t}\\n\\n\\t// Get date when policy becomes inactive.\\n\\tget validTillUnformatted() {\\n\\t\\treturn this.calculateValidTill(this._validFrom, this._validMonths); //return Date object\\n\\t}\\n\\n\\n\\t// Get total price of the policy. Calculate by summing up all insured risks.\\n\\t// Take into account that price of the risk is given for 1 full year. Policy/risk period can be shorter.\\n\\tget premium() {\\n\\t\\tlet sum = 0;\\n\\n\\t\\tthis.insuredRisks.forEach(function(elem){\\n\\t\\t\\tsum += ((elem._yearlyPrice/12)*this._validMonths);\\n\\t\\t},this);\\n\\n\\t\\treturn Math.ceil(sum); //round a fraction in favor of the seller\\n\\t}\\n\\t\\n\\t// Get list of the Risks that are included in the policy at given time moment.\\n\\tget insuredRisks() {\\n\\t\\tlet arr = [];\\t\\n\\n\\t\\tthis._selectedRisks.forEach(function(elem){\\n\\t\\t\\tarr.push(elem);\\n\\t\\t});\\n\\n\\t\\treturn arr;\\n\\t}\\n}\\n\\n// Convert Date Object to String 'yyyy-mm-dd' expected in the task (.html)\\n// date: Date object\\nfunction formatDate(date) {\\n    let d = new Date(date),\\n        month = '' + (d.getMonth() + 1),\\n        day = '' + d.getDate(),\\n        year = d.getFullYear();\\n\\n    if (month.length < 2) month = '0' + month;\\n    if (day.length < 2) day = '0' + day;\\n\\n    return [year, month, day].join('-');\\n}\\n\\n// Return true if the date is not in the past in relation to the current day, otherwise false\\n// date: Date object\\nfunction dateNotPast(date) {\\n\\tlet nowDate = new Date();\\n\\tif(date.getTime() < nowDate.getTime()) return false;\\n\\treturn true;\\n}\\n\\n// Export classes for Jest testing framework (script.test.js)\\nmodule.exports = {\\n  InsuranceCompany : InsuranceCompany,\\n  Risk : Risk,\\n  Policy: Policy\\n}\\n\",\"console.log('script2');\"]}","code":"!function(e){var t={};function i(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,i),n.l=!0,n.exports}i.m=e,i.c=t,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,\"a\",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p=\"\",i(i.s=0)}([function(e,t,i){i(1),i(2)},function(e,t){class i{constructor(e,t,i,r){this._nameOfInsuredObject=e,this._validFrom=t,this._validMonths=i,this._selectedRisks=r}get nameOfInsuredObject(){return this._nameOfInsuredObject}get validFrom(){return this._validFrom}calculateValidTill(e,t){let i=new Date(e.getTime()),r=new Date(i.setMonth(i.getMonth()+t));return new Date(r.setDate(r.getDate()-1))}get validTill(){return function(e){let t=new Date(e),i=\"\"+(t.getMonth()+1),r=\"\"+t.getDate(),n=t.getFullYear();i.length<2&&(i=\"0\"+i);r.length<2&&(r=\"0\"+r);return[n,i,r].join(\"-\")}(this.calculateValidTill(this._validFrom,this._validMonths))}get validTillUnformatted(){return this.calculateValidTill(this._validFrom,this._validMonths)}get premium(){let e=0;return this.insuredRisks.forEach(function(t){e+=t._yearlyPrice/12*this._validMonths},this),Math.ceil(e)}get insuredRisks(){let e=[];return this._selectedRisks.forEach(function(t){e.push(t)}),e}}function r(e){let t=new Date;return!(e.getTime()<t.getTime())}e.exports={InsuranceCompany:class{constructor(e){this._name=e,this._risks=[],this._soldPolicies=[]}get name(){return this._name}get availableRisks(){return this._risks}addSoldPolicy(e){this._soldPolicies.push(e)}get soldPolicies(){return this._soldPolicies}setAvailableRisks(e){this._risks=[],e instanceof Array?e.forEach(function(e){this._risks.push(e)},this):this._risks.push(e)}isAvailable(e){for(let t of Object.keys(e)){let i=e[t];if(!this.availableRisks.includes(i))return!1}return!0}sellPolicy(e,t,n,l){if(!r(t))return void console.log(\"error: Policy date can not be in the past\");if(!this.isAvailable(l))return;let s=!1,o=new i,a=t.getTime(),c=o.calculateValidTill(t,n).getTime();if(this.soldPolicies.forEach(function(t){let i=t._validFrom.getTime(),r=t.validTillUnformatted.getTime();(a<=i&&c>=r||a>=i&&a<=r||c>=i&&a<=i)&&e==t.nameOfInsuredObject&&(s=!0)}),!s){let r=new i(e,t,n,l);return this.addSoldPolicy(r),r}console.log(\"error: Effective periods of different policies overlap each other\")}getPolicy(e,t){let i,r=this._soldPolicies,n=t.getTime();return r.forEach(function(t){t.nameOfInsuredObject==e&&n>=t.validFrom.getTime()&&n<=t.validTillUnformatted.getTime()&&(i=t)}),i}addRisk(e,t,i){this.isAvailable([t])&&(r(i)?this.getPolicy(e,i)._selectedRisks.push(t):console.log(\"error: Risk date can not be in the past\"))}},Risk:class{constructor(e,t){this._name=e,this._yearlyPrice=t}get name(){return this._name}yearlyPrice(){return this._yearlyPrice}},Policy:i}},function(e,t){console.log(\"script2\")}]);","extractedComments":[]}