{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./script.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;AClFA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;;AAE9C;AACA,iCAAiC;AACjC,+BAA+B;AAC/B,2EAA2E;;AAE3E;;AAEA;AACA,oCAAoC;AACpC,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA,iFAAiF;AACjF;;AAEA;AACA;AACA,qEAAqE;AACrE;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH,wBAAwB;AACxB;;AAEA;AACA;AACA,e;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G","file":"script.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","class InsuranceCompany {\n\n\tconstructor(name) {\n\t\tthis._name = name;\n\t\tthis._risks = [];\n\t\tthis._soldPolicies = [];\n\t}\n\n\t// Get name of the company\n\tget name() {\n\t\treturn this._name;\n\t}\n\t\n\t// Get list of the risks that can be insured.\n\tget availableRisks() {\n\t\treturn this._risks;\n\t}\n\t\n\t// Add a new policy to the list\n\taddSoldPolicy(policy) {\n\t\tthis._soldPolicies.push(policy);\n\t}\n\n\t// Get list of all sold policies\n\tget soldPolicies() {\n\t\treturn this._soldPolicies;\n\t}\n\t\n\t// Set list of the risks that can be insured. List can be updated at any time.\n\t// risks: Array of Risks or single Risk\n\tsetAvailableRisks(risks) {\n\t\tthis._risks = [];\n\t\tif(!(risks instanceof Array)) this._risks.push(risks); //if only one element is passed, will not use foreach\n\t\telse {\n\t\t\trisks.forEach(function(elem){\n\t\t\t\tthis._risks.push(elem);\n\t\t\t}, this);\n\t\t}\n\t}\n\n\t// Return true if Risk is available\n\t// risks: Array of Risks \n\tisAvailable(risks) {\n\t\tfor (let risk of Object.keys(risks)) {\n\t\t    let currentRisk = risks[risk];\n\t\t\tif (!this.availableRisks.includes(currentRisk)) { // If one of selected risks is not available reject to sell policy\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\t\n\t// Sell the policy.\n\t// nameOfInsuredObject: Name of the insured object. Must be unique in the given period.\n\t// validFrom: Date and time when policy starts. Can not be in the past\n\t// validMonths: (number) Policy period in full months\n\t// selectedRisks: List of risks objects that must be included in the policy\n\tsellPolicy(nameOfInsuredObject, validFrom, validMonths, selectedRisks) {\n\t\tif(!dateNotPast(validFrom)) {\n\t\t\tconsole.log('error: Policy date can not be in the past');\n\t\t\treturn;\n\t\t}\n\n\t\tif(!this.isAvailable(selectedRisks)) return; //refuse to sell policy if risk is not available\n\n\t\tlet overlap = false;\n\t\tlet policyClass = new Policy(); //create an instance of class to access calculateValidTill method\n\t\tlet f2 = validFrom.getTime(); // validFrom candidate for new Policy object\n\t\tlet t2 = policyClass.calculateValidTill(validFrom,validMonths).getTime(); // validTill candidate for new Policy object\n\n\t\tlet sp = this.soldPolicies;\n\n\t\tsp.forEach(function(el){\n\t\t\tlet f1 = el._validFrom.getTime(); // validFrom already existing Policy object\n\t\t\tlet t1 = el.validTillUnformatted.getTime(); // valid Till already existing Policy object\n\t\t\t\n\t\t\t/*\n\t\t\tcases when effective periods overlap each other:\n\t\t\t\tf2<=f1 && t2>=t1\n\t\t\t\tf2>=f1 && f2<=t1\n\t\t\t\tt2>=f1 && f2<=f1\n\n\t\t\t\tf - from , t - to\n\t\t\t\t1 - already existing Policy object\n\t\t\t\t2 - candidate for new Policy object\n\t\t\t*/\n\t\t\tif (((f2<=f1 && t2>=t1) || (f2>=f1 && f2<=t1) || (t2>=f1 && f2<=f1)) && nameOfInsuredObject == el.nameOfInsuredObject) \n\t\t\t\toverlap = true;\n\t\t});\n\n\t\tif(!overlap) {\n\t\t\tlet newPolicy = new Policy(nameOfInsuredObject, validFrom, validMonths, selectedRisks);\n\t\t\tthis.addSoldPolicy(newPolicy);\n\t\t\treturn newPolicy;\n\t\t} else {\n\t\t\tconsole.log('error: Effective periods of different policies overlap each other');\n\t\t}\n\t}\n\n\t// Gets policy with a risks at the given point of time.\n\t// nameOfInsuredObject: Name of insured object\n\t// effectiveDate: Point of date and time, when to get data about a policy\n\tgetPolicy(nameOfInsuredObject, effectiveDate) {\n\t\tlet policies = this._soldPolicies;\n\t\tlet efDateTime = effectiveDate.getTime();\n\t\tlet toReturn;\n\n\t\tpolicies.forEach(function(el){\n\t\t\tif (el.nameOfInsuredObject == nameOfInsuredObject && (efDateTime >= el.validFrom.getTime() && efDateTime <= el.validTillUnformatted.getTime())) {\n\t\t\t\ttoReturn = el;\n\t\t\t}\n\t\t});\n\n\t\treturn toReturn;\n\t}\n\n\t// Add risk to the policy of insured object.\n\t// nameOfInsuredObject: Name of insured object\n\t// risk: Risk that must be added\n\t// validFrom: Date when _policy_ becomes active. Can not be in the past\n\taddRisk(nameOfInsuredObject, risk, validFrom) {\n\t\tif(!this.isAvailable([risk])) return; //refuse to add risk if not available\n\n\t\tif(dateNotPast(validFrom)) {\n\t\t\tlet currentPolicy = this.getPolicy(nameOfInsuredObject, validFrom);\n\t\t\tcurrentPolicy._selectedRisks.push(risk);\n\t\t} else {\n\t\t\tconsole.log('error: Risk date can not be in the past');\n\t\t}\n\t}\n}\n\nclass Risk {\n\n\tconstructor(name, yearlyPrice) {\n\t\tthis._name = name;\n\t\tthis._yearlyPrice = yearlyPrice;\n\t}\n\n\t// Get name of the Risk\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\t// Get yearly price of the Risk\n\tyearlyPrice() {\n\t\treturn this._yearlyPrice;\n\t}\n}\n\t\nclass Policy {\n\n\tconstructor(nameOfInsuredObject, validFrom, validMonths, selectedRisks) {\n\t\tthis._nameOfInsuredObject = nameOfInsuredObject;\n\t\tthis._validFrom = validFrom;\n\t\tthis._validMonths = validMonths;\n\t\tthis._selectedRisks = selectedRisks;\n\t}\n\n\t// Get name of insured object.\n\tget nameOfInsuredObject() {\n\t\treturn this._nameOfInsuredObject;\n\t}\n\t\n\t// Get date when policy becomes active.\n\tget validFrom() {\n\t\treturn this._validFrom;\n\t}\n\n\t// Get date when policy becomes inactive\n\t// from: Date and time when policy starts. Can not be in the past\n\t// months: (number) Policy period in full months\n\tcalculateValidTill(from, months) {\n\t\tlet fromCopy = new Date(from.getTime()); //copy the argument to not change the original\n\t\tlet till = new Date(fromCopy.setMonth(fromCopy.getMonth()+months));\n\t\treturn new Date(till.setDate(till.getDate()-1)); //convert to needed form\n\t}\n\n\t// Get date when policy becomes inactive.\n\tget validTill() {\n\t\treturn formatDate(this.calculateValidTill(this._validFrom, this._validMonths)); //return String in the 'yyyy-mm-dd' format\n\t}\n\n\t// Get date when policy becomes inactive.\n\tget validTillUnformatted() {\n\t\treturn this.calculateValidTill(this._validFrom, this._validMonths); //return Date object\n\t}\n\n\n\t// Get total price of the policy. Calculate by summing up all insured risks.\n\t// Take into account that price of the risk is given for 1 full year. Policy/risk period can be shorter.\n\tget premium() {\n\t\tlet sum = 0;\n\n\t\tthis.insuredRisks.forEach(function(elem){\n\t\t\tsum += ((elem._yearlyPrice/12)*this._validMonths);\n\t\t},this);\n\n\t\treturn Math.ceil(sum); //round a fraction in favor of the seller\n\t}\n\t\n\t// Get list of the Risks that are included in the policy at given time moment.\n\tget insuredRisks() {\n\t\tlet arr = [];\t\n\n\t\tthis._selectedRisks.forEach(function(elem){\n\t\t\tarr.push(elem);\n\t\t});\n\n\t\treturn arr;\n\t}\n}\n\n// Convert Date Object to String 'yyyy-mm-dd' expected in the task (.html)\n// date: Date object\nfunction formatDate(date) {\n    let d = new Date(date),\n        month = '' + (d.getMonth() + 1),\n        day = '' + d.getDate(),\n        year = d.getFullYear();\n\n    if (month.length < 2) month = '0' + month;\n    if (day.length < 2) day = '0' + day;\n\n    return [year, month, day].join('-');\n}\n\n// Return true if the date is not in the past in relation to the current day, otherwise false\n// date: Date object\nfunction dateNotPast(date) {\n\tlet nowDate = new Date();\n\tif(date.getTime() < nowDate.getTime()) return false;\n\treturn true;\n}\n\n// Export classes for Jest testing framework (script.test.js)\n/*\nmodule.exports = {\n  InsuranceCompany : InsuranceCompany,\n  Risk : Risk,\n  Policy: Policy\n}\n*/\n//1"],"sourceRoot":""}